# Part 4: I/O Device Administration and I/O Management in RHEL

## 1. I/O Devices Relevant to This Project

Although the prime-number workload is mostly CPU-bound, the project still uses
I/O paths for configuration, logging, and result storage.

### Inputs
- Command-line arguments (limit, threads, scheduling policy)
- MPI hostfile (for multi-node MPI runs)
- Optional environment variables and system configuration (scheduler policy)

### Outputs
- Standard output and error (terminal)
- CSV benchmark files stored under `results/`
- Reports generated by scripts under `results/`

### Device Identification Commands (RHEL)
- `lsblk` (block devices: disks, partitions)
- `lspci` (PCI devices: storage controllers, NICs)
- `lsusb` (USB devices)
- `df -hT` and `findmnt` (filesystem and mount details)

The project includes a helper script:
- `./scripts/io-analysis.sh` â†’ produces `results/io-analysis-report.md`

## 2. How RHEL Manages I/O (Organization Techniques)

### Programmed I/O (PIO)
- The CPU directly reads/writes device registers and performs data transfers.
- Usually used for small control operations, not bulk data movement.
- High CPU overhead.

### Interrupt-Driven I/O
- The device interrupts the CPU when it needs service (e.g., request completion).
- Improves CPU utilization vs polling.
- Common for signaling completion even when DMA is used for bulk data.

### Direct Memory Access (DMA)
- A DMA engine transfers data between device and memory without CPU copying.
- CPU sets up the transfer and handles completion via interrupts.
- Best for throughput and CPU efficiency.

## 3. Which Technique is Best for This Application?

For this project:
- The prime calculation itself is CPU-bound.
- I/O happens mostly when:
  - printing to STDOUT
  - writing CSV results to disk
  - launching processes/containers/MPI jobs

**Most efficient approach:**
- Keep output minimal during benchmarks (CSV only).
- Write results in batches (append once per run, not per prime).
- Rely on the OS page cache + buffered I/O.

In practice, modern storage uses **DMA for data transfer** and **interrupts for
completion**, which is already efficient for our usage.

## 4. Commands to Inspect Devices and the I/O Path

Examples:

```bash
lsblk -a -o NAME,TYPE,SIZE,ROTA,MOUNTPOINTS,FSTYPE,MODEL
df -hT
findmnt -a

lspci -nnk | less
lsusb

cat /proc/interrupts | head
systemctl status irqbalance --no-pager

# If sysstat is installed:
iostat -xz 1 3
```

## 5. Running the Automated I/O Analysis

```bash
pnpm run io:analyze
# or
./scripts/io-analysis.sh
```

Outputs:
- `results/io-analysis-report.md`
- `results/io-raw/*.txt`
